/***************************** Signals *****************************************
 *
 * A signal is an asynchronous notification sent to a process or to a specific thread within the same process in order to notify it of an event that occurred.
 * When a signal is sent, the operating system interrupts the target process normal flow of execution to deliver the signal.
 * If the process has previously registered a signal handler, that routine is executed. Otherwise, the default signal handler is executed.
 *
*******************************************************************************/

/***************************** Standard Signals ********************************
 *
 * The C standard defines only 6 signals. They are all defined in signal.h header (csignal header in C++)
 *
 * SIGABRT   - abnormal termination.
 * SIGFPE    - floating point exception.
 * SIGILL    - invalid instruction.
 * SIGINT    - interactive attention request sent to the program.
 * SIGSEGV   - invalid memory access ( segmentation fault).
 * SIGTERM   - termination request sent to the program.
 *
 * Windows supports only standard signals.
 * Additional signals may be specified in the signal.h header by the implementation.
 * For example, Unix and Unix-like operating systems (such as Linux) define more than 15 additional signals
 *
 * https://en.wikipedia.org/wiki/C_signal_handling
 * https://en.wikipedia.org/wiki/Unix_signal
 *
*******************************************************************************/

/***************************** Default Behaviours ******************************
 *
 * When a process receives a signal, there are four possible outcomes:
 * 
 * Term         -> Terminate the process. Additionally may write a image of the process state in a core file, which can be later examined using debugger
 * Ign          -> Nothing occurs, completely ignoring the signal
 * Stop         -> suspends process execution, but retains it in memory, so may continue/restart by sending additional signal to the process
 * Cont         -> The signal triggers/resume the execution of the process
 *
 * 	Name			Event					Default Behavior
 *
 * 	SIGHUB		Hang-up (end of connection)			Termination
 * 	SIGINT		Interruption (ctrl-C)				Termination
 * 	SIGQUIT		Strong interruption (ctrl-\)			Term. & core dump
 * 	SIGFPE		Arithmetic error (division by zero)		Term. & core dump
 * 	SIGKILL		Very strong interruption (cannot be ignored)	Termination
 * 	SIGSEGV		Memory protection violation			Term. & core dump
 * 	SIGPIPE		Writing to a pipe without readers		Termination
 * 	SIGALRM		Timer interrupt					Ignored
 * 	SIGTSTP		Temporary halt (ctrl-Z)				Suspension
 * 	SIGCONT		Resuming a stopped process			Ignored
 * 	SIGCHLD		A child process died or was stopped		Ignored 

 *
 * SIGABRT   -> abort() is usually called by library functions which detect an internal error or some seriously broken constraint.
 *           -> For example malloc() will call abort() if its internal structures are damaged by a heap overflow
 * SIGHUB    -> Report that user's terminal is disconnected. Signal used to report the termination of the controlling process
 *
 *
*******************************************************************************/

/***************************** Signal Handling  ********************************
 *
 * A signal can be generated by calling raise() or kill() system calls.
 *
 * raise() sends a signal to the current process, kill() sends a signal to a specific process. 
 *
 * A signal handler is a function which is called by the target environment when the corresponding signal occurs
 * The target environment suspends execution of the program until the signal handler returns or calls longjmp()
 * 
 * signal() -> sets the action taken when the program receives a specific signal
 * raise()  -> sends a signal to the calling process or thread
 * kill()   -> can be used to send any signal to any process group or process.
 *          -> kill -l ( for list of signals )
 *
 * header   -> signal.h
 * return   -> kill() = pthread_kill() = raise() = 0, signal() = Returns the previous value of the signal handler, or SIG_ERR on error.
 *
 * The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
 * 
*******************************************************************************/

/***************************** API Definition **********************************
 *
 * typedef void (*sighandler_t)(int)
 *
 * sighandler_t signal(int signum, sighandler_t handler)
 *
 * int raise(int sig)
 *
 * int kill(pid_t pid, int sig)
 *
 * int pthread_kill(pthread_t thread, int sig)
 *
*******************************************************************************/

/***************************** Signal Safe functions ***************************

The following table defines a set of functions that shall be async-signal-safe.
Therefore, applications can invoke them, without restriction, from signal-catching functions

_Exit()             fexecve()           posix_trace_event() sigprocmask()
_exit()             fork()              pselect()           sigqueue()
abort()             fstat()             pthread_kill()      sigset()
accept()            fstatat()           pthread_self()      sigsuspend()
access()            fsync()             pthread_sigmask()   sleep()
aio_error()         ftruncate()         raise()             sockatmark()
aio_return()        futimens()          read()              socket()
aio_suspend()       getegid()           readlink()          socketpair()
alarm()             geteuid()           readlinkat()        stat()
bind()              getgid()            recv()              symlink()
cfgetispeed()       getgroups()         recvfrom()          symlinkat()
cfgetospeed()       getpeername()       recvmsg()           tcdrain()
cfsetispeed()       getpgrp()           rename()            tcflow()
cfsetospeed()       getpid()            renameat()          tcflush()
chdir()             getppid()           rmdir()             tcgetattr()
chmod()             getsockname()       select()            tcgetpgrp()
chown()             getsockopt()        sem_post()          tcsendbreak()
clock_gettime()     getuid()            send()              tcsetattr()
close()             kill()              sendmsg()           tcsetpgrp()
connect()           link()              sendto()            time()
creat()             linkat()            setgid()            timer_getoverrun()
dup()               listen()            setpgid()           timer_gettime()
dup2()              lseek()             setsid()            timer_settime()
execl()             lstat()             setsockopt()        times()
execle()            mkdir()             setuid()            umask()
execv()             mkdirat()           shutdown()          uname()
execve()            mkfifo()            sigaction()         unlink()
faccessat()         mkfifoat()          sigaddset()         unlinkat()
fchdir()            mknod()             sigdelset()         utime()
fchmod()            mknodat()           sigemptyset()       utimensat()
fchmodat()          open()              sigfillset()        utimes()
fchown()            openat()            sigismember()       wait()
fchownat()          pause()             signal()            waitpid()
fcntl()             pipe()              sigpause()          write()
fdatasync()         poll()              sigpending()

*******************************************************************************/

/* https://en.wikipedia.org/wiki/Unix_signal
 * http://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals
 * https://en.wikipedia.org/wiki/C_signal_handling
 * http://www.linuxprogrammingblog.com/all-about-linux-signals?page=show
 *
 * broken pipe
 * SIGALRM for windows
 * volatile memory in c
 * changing effect of a signal
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <signal.h>
#include <time.h>

#ifdef _WIN32	
	#include <io.h>
	#include <process.h>
	#include <windows.h>
	#define STDOUT_FILENO 1
	#define SIGALRM 14
	int alarm(int secs, void (*callback)(int));
#else
	#include <unistd.h>
	#include <sys/wait.h>
#endif


#ifdef __linux__
	#include <execinfo.h>
	void printTrace();
#endif


void buggy_function();
void DBGPRINT(const char *fmt, ...);
void simpleFork();

void sigHandler(int signal);

int main()
{
	int choice = 0;
	int result = 0;
	int zero = 0;

	while ( 1 )
	{
		fpurge(stdin);
		printf("\n\n\n ---------- Signal Test --------------");
		printf("\n%02d. SIGABRT                      -> Abort", SIGABRT);
		printf("\n%02d. SIGFPE                       -> Floating point Exception", SIGFPE);
		printf("\n%02d. SIGILL                       -> Invalid instruction", SIGILL);
		printf("\n%02d. SIGSEGV                      -> Access violation / Segmentation fault", SIGSEGV);
		printf("\n%02d. SIGTERM                      -> Terminate -> 'kill pid'", SIGTERM);
		printf("\n%02d. SIGINT                       -> Interrupt -> CTRL+C", SIGINT);
#ifndef _WIN32
		printf("\n%02d. SIGQUIT                      -> Quit      -> CTRL+\\", SIGQUIT);
		printf("\n%02d. SIGSTOP                      -> Stop/Pause-> CTRL+Z", SIGSTOP);
		printf("\n%02d. SIGCONT                      -> Resume    -> kill -SIGCONT pid", SIGCONT);
		printf("\n%02d. SIGCHLD                      -> Child termination signal, useful bcoz no need to call wait() and wait", SIGCHLD);
#endif
		printf("\n%02d. SIGALRM                      -> Alarm timer", SIGALRM);	
		printf("\n99. Exit");
		printf("\nEnter choice : ");
		scanf("%d", &choice);

		switch(choice)
		{
			case SIGABRT:
				signal(SIGABRT, sigHandler);
				abort(); // raise(SIGABRT) or kill(getpid(), SIGABRT)
				printf("\nThis will not be print, as we terminated the process using abort()");
				break;

			case SIGFPE:
				signal(SIGFPE, sigHandler);
				result = 5/ zero;
				printf("\nThis will not be print, as SIGFPE happened");
				break;

			case SIGILL:
				signal(SIGILL, sigHandler);
				printf("\nThis will not be print, as SIGILL happened");
				break;

			case SIGSEGV:
				signal(SIGSEGV, sigHandler);
				printf("\nsignal SIGSEGV initialized");
				buggy_function();
				
				break;
			
			case SIGTERM:
				signal(SIGTERM, sigHandler);
				printf("\nsignal SIGTERM initialized, use 'kill pid' for raise terminate signal, use 'ps' to list and get pid");
#ifdef _WIN32
				//kill(_getpid(), SIGTERM);
				raise(SIGTERM);
#else
				kill(getpid(), SIGTERM);
#endif
				break;

			case SIGINT:
				signal(SIGINT, sigHandler);
				printf("\nsignal SIGINT initialized, press CTRL+C to raise interrupt signal");
				break;

#ifdef _WIN32
			case SIGALRM:
				alarm(15, sigHandler);
				printf("\nsignal SIGALRM initialized, timer set to 15 seconds");
				break;
#else
			case SIGALRM:
				signal(SIGALRM, sigHandler);
				alarm(15);
				printf("\nsignal SIGALRM initialized, timer set to 15 seconds");
				break;

			case SIGQUIT:
				signal(SIGQUIT, sigHandler);
				printf("\nsignal SIGQUIT initialized, press CTRL+\\ to raise quit signal");
				break;

			case SIGSTOP:
				signal(SIGSTOP, sigHandler);
				printf("\nsignal SIGSTOP initialized, press CTRL+Z to raise stop signal");
				break;

			case SIGCONT:
				signal(SIGCONT, sigHandler);
				printf("\nsignal SIGCONT initialized, use 'kill -SIGCONT pid' for raise SIGCONT signal");
				break;

			case SIGCHLD:
				signal(SIGCHLD, sigHandler);
				printf("\nsignal SIGCHLD initialized, fork() and dont call wait() and wait for SIGCHLD signal and then call wait()");
				simpleFork();
				break;
#endif			
			case 99:
				exit(0);
			default:
				printf("\nInvalid choice , try again !!!");
				break;
		}
	}

	return 0;
}


void sigHandler(int signal)
{
	switch(signal)
	{
		case SIGABRT:
			DBGPRINT("\nReceived signal SIGFPE %d", signal);  // We r not using printf(), because its not safe inside signal handlers
			break;

		case SIGFPE:
			DBGPRINT("\nReceived signal SIGFPE %d", signal);
			break;

		case SIGILL:                   // need to add example here
			DBGPRINT("\nReceived signal SIGILL %d", signal);
			break;

		case SIGSEGV:
			DBGPRINT("\nReceived signal SIGSEGV %d", signal);
#ifdef __linux__
			printTrace();
#endif
			break;	

		case SIGTERM:                                              // use 'ps' to view list of processes.
			DBGPRINT("\nReceived signal SIGTERM %d", signal);  // normal kill ('kill pid') signal will be catch here and application will not be terminate.
			break;                                             // use 'kill -SIGKILL pid' for kill it forcefully and this signal is not catchable by app.

		case SIGINT:
			DBGPRINT("\nReceived signal SIGINT %d", signal);
			break;
#ifdef _WIN32
		case SIGALRM:
			DBGPRINT("\nReceived signal SIGALRM %d", signal);
			alarm(15, sigHandler);     // setting alarm again
			break;
#else
		case SIGALRM:
			DBGPRINT("\nReceived signal SIGALRM %d", signal);
			alarm(15);     // setting alarm again
			break;

		case SIGQUIT:
			DBGPRINT("\nReceived signal SIGQUIT %d", signal);
			break;

		case SIGSTOP:
			DBGPRINT("\nReceived signal SIGSTOP %d", signal);
			break;

		case SIGCONT:
			DBGPRINT("\nReceived signal SIGCONT %d", signal);
			break;

		case SIGCHLD:
			DBGPRINT("\nReceived signal SIGCHLD %d and child pid is %d", signal, wait(NULL)); // read child status info for avoid zombie
			break;	
#endif
	}

}

void DBGPRINT(const char *fmt, ...)
{
	char buffer[512] = {0};
	va_list args;
	va_start(args, fmt);
	vsprintf (buffer, fmt, args );
	va_end(args);
	write(STDOUT_FILENO, buffer, strlen(buffer));
}



#ifdef _WIN32

typedef struct
{
	int sec;
	void (*callback)(int);
}ARGS;

ARGS args = {0};


int delay(int seconds)
{
	clock_t end_wait = clock() + seconds * CLOCKS_PER_SEC;
	while( clock() < end_wait )
		;

	return 0;
}

DWORD WINAPI setTimerCalback(void *args)
{
	ARGS arg = *(ARGS *)args;
	bool timerWait = true;

#if 0
	MSG Msg;
	UINT TimerId = (UINT)SetTimer(NULL, 0, arg.sec * 1000, NULL); // 0 minute

	while (timerWait)
	{
		GetMessage(&Msg, NULL, 0, 0);

		if (Msg.message == WM_TIMER)
			timerWait = false;

		DispatchMessage(&Msg);
	}

	KillTimer(NULL, TimerId);
#elif 0
	delay(arg.sec);
#else
	Sleep(arg.sec * 1000);
#endif
	arg.callback(SIGALRM);

	return 0;
}



int alarm(int secs, void (*callback)(int))
{
	HANDLE handle = NULL;
	memset(&args, 0, sizeof(args));
	
	args.sec = secs;
	args.callback = callback;

	handle = CreateThread( NULL, 0, setTimerCalback, (void *)&args, 0, NULL);

	return 0;

}



#else

void simpleFork()
{
	pid_t pid = 0;

	switch( pid = fork())
	{
		case -1: printf("\nfork() failed"); break;
		case 0: printf("\nChild process"); _exit(0); break;   // Think wat will happen, if we dont give _exit() here
		default: printf("\nParent process"); break;
	}
}

#endif


void buggy_function()
{
	char *p = NULL;

	memcpy( p, "i shouldn't be here!", 0xFF );
}




#ifdef __linux__

void printTrace()
{
	void *trace[32];
	size_t size, i;
	char **strings;

	size = backtrace(trace, 32);
	strings = backtrace_symbols( trace, size );

	DBGPRINT("\n-----------Backtrace----------");

	for ( i = 0; i < size; i++)
		DBGPRINT("\n%s", strings[i]);
}

#endif
