**Advanced Linux System Calls for System Programming**

---

### ðŸ”‹ Multithreading & Synchronization
| System Call     | Purpose                                                                 |
|------------------|-------------------------------------------------------------------------|
| `futex()`        | Fast userspace mutex; base for pthread sync primitives                  |
| `clone()`        | Low-level thread creation (used by `pthread_create()`)                  |
| `setns()`        | Enter a different namespace (e.g., for containers)                      |
| `gettid()`       | Get thread ID directly (not same as `getpid()`)                         |

---

### ðŸ“ˆ Memory Management
| System Call       | Purpose                                                                 |
|-------------------|--------------------------------------------------------------------------|
| `mmap()`          | Map files or anonymous memory into user space                           |
| `mremap()`        | Resize existing `mmap()` regions                                        |
| `mlock()` / `munlock()` | Lock/unlock memory to prevent paging to disk                    |
| `madvise()`       | Provide hints to kernel about memory usage (e.g., `MADV_HUGEPAGE`)      |
| `userfaultfd()`   | Trap and manage page faults in user space                               |

---

### ðŸ”„ Zero-Copy / High-Performance I/O
| System Call     | Purpose                                                                 |
|------------------|-------------------------------------------------------------------------|
| `sendfile()`     | Zero-copy transfer from file to socket                                  |
| `splice()`       | Move data between file descriptors via kernel pipes                     |
| `tee()`          | Duplicate data from one pipe to another without copying                 |
| `vmsplice()`     | Transfer user memory to a pipe (optionally zero-copy)                   |
| `io_uring`       | Modern async I/O system with shared ring buffers                        |

---

### ðŸ“¡ Networking & Epoll-Based I/O
| System Call       | Purpose                                                                 |
|-------------------|--------------------------------------------------------------------------|
| `epoll_create1()` | Create epoll instance                                                   |
| `epoll_ctl()`     | Add/mod/remove file descriptors in epoll set                            |
| `epoll_wait()`    | Wait for I/O readiness events                                           |
| `accept4()`       | Accept new socket connection + set flags in one syscall                 |
| `recvmmsg()` / `sendmmsg()` | Batch message receive/send for UDP/packet-based sockets     |
| `io_uring_register()` | Register files, buffers, etc. for async performance               |

---

### ðŸ” Security, Capabilities, Namespaces
| System Call     | Purpose                                                                 |
|------------------|-------------------------------------------------------------------------|
| `seccomp()`      | Secure computing mode (restrict syscall access)                          |
| `capget()` / `capset()` | Manipulate fine-grained process capabilities                     |
| `unshare()`      | Run process in new namespace (network, mount, etc.)                     |
| `keyctl()`       | Kernel keyring management                                               |

---

### ðŸ”® Observability, Performance, Debugging
| System Call         | Purpose                                                                |
|----------------------|-------------------------------------------------------------------------|
| `perf_event_open()`  | Access hardware/software performance counters (used by `perf`)          |
| `ptrace()`           | Trace or control execution of another process (used in `gdb`, `strace`) |
| `bpf()`              | Load and manage eBPF programs (filtering, tracing, security)            |

---

### ðŸŒŸ Must-Know System Calls for Expert Programmers
- `epoll_*()`     â€” For scalable, multiplexed I/O handling
- `futex()`       â€” High-performance synchronization
- `splice()`      â€” Pipe-based zero-copy data transfers
- `io_uring`      â€” Modern async I/O with deep performance control
- `mmap()`        â€” Map files/memory with direct access
- `userfaultfd()` â€” Handle memory page faults in user space

---

### ðŸ’¡ Full Working Demos (With Build Instructions)

#### ðŸ§ª Compile Commands
```sh
gcc -o futex_example futex_example.c -pthread
gcc -o userfaultfd_example userfaultfd_example.c -pthread
gcc -o io_uring_example io_uring_example.c -luring
```
> Install dependency:
```sh
sudo apt install liburing-dev
```

---

### ðŸ“˜ Code Examples

(includes all code blocks: sendfile, splice, epoll, mmap, clone, futex, userfaultfd, io_uring)
**Advanced Linux System Calls for System Programming**

--- SNIPPED HEADER ---

### ðŸ“˜ Code Examples

**`sendfile()` example:**
```c
int file_fd = open("file.txt", O_RDONLY);
off_t offset = 0;
sendfile(socket_fd, file_fd, &offset, file_size);
```

**`splice()` example:**
```c
int pipefd[2];
pipe(pipefd);
splice(file_fd, NULL, pipefd[1], NULL, 65536, 0);
splice(pipefd[0], NULL, socket_fd, NULL, 65536, 0);
```

**`epoll` loop example:**
```c
int epfd = epoll_create1(0);
struct epoll_event ev = { .events = EPOLLIN, .data.fd = sock_fd };
epoll_ctl(epfd, EPOLL_CTL_ADD, sock_fd, &ev);
int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);
```

**`mmap()` example:**
```c
int fd = open("file.dat", O_RDONLY);
void *addr = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
```

**`clone()` example:**
```c
int child_stack[8192];
clone(child_func, child_stack + 8192, CLONE_VM | CLONE_FS | CLONE_FILES, NULL);
```

**`futex()` full working example:**
```c
#include <linux/futex.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdint.h>
#include <pthread.h>
#include <stdio.h>

int futex_val = 0;

void* waiter(void* arg) {
    printf("[Waiter] Waiting for futex\n");
    syscall(SYS_futex, &futex_val, FUTEX_WAIT, 0, NULL, NULL, 0);
    printf("[Waiter] Woken up\n");
    return NULL;
}

int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, waiter, NULL);
    sleep(2);
    futex_val = 1;
    printf("[Main] Waking up waiter\n");
    syscall(SYS_futex, &futex_val, FUTEX_WAKE, 1, NULL, NULL, 0);
    pthread_join(tid, NULL);
    return 0;
}
```

**`userfaultfd()` full working example:**
```c
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <poll.h>
#include <pthread.h>
#include <sys/ioctl.h>

#define PAGE_SIZE 4096

void* fault_handler_thread(void* arg) {
    int uffd = *(int*)arg;
    struct uffd_msg msg;
    struct pollfd pollfd = { uffd, POLLIN, 0 };
    poll(&pollfd, 1, -1);
    read(uffd, &msg, sizeof(msg));
    printf("[Handler] Page fault at address: %p\n", (void*)msg.arg.pagefault.address);
    return NULL;
}

int main() {
    void* addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    int uffd = syscall(SYS_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    struct uffdio_api api = { .api = UFFD_API };
    ioctl(uffd, UFFDIO_API, &api);

    struct uffdio_register reg = {
        .range.start = (unsigned long)addr,
        .range.len = PAGE_SIZE,
        .mode = UFFDIO_REGISTER_MODE_MISSING
    };
    ioctl(uffd, UFFDIO_REGISTER, &reg);

    pthread_t thr;
    pthread_create(&thr, NULL, fault_handler_thread, &uffd);

    printf("[Main] Accessing page to trigger page fault...\n");
    ((char*)addr)[0] = 'X';

    pthread_join(thr, NULL);
    return 0;
}
```

**`io_uring` full working example:**
```c
#include <liburing.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main() {
    struct io_uring ring;
    io_uring_queue_init(4, &ring, 0);

    int fd = open("test.txt", O_RDONLY);
    char buffer[1024] = {0};

    struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
    io_uring_prep_read(sqe, fd, buffer, sizeof(buffer), 0);
    io_uring_submit(&ring);

    struct io_uring_cqe *cqe;
    io_uring_wait_cqe(&ring, &cqe);
    printf("Read: %s\n", buffer);
    io_uring_cqe_seen(&ring, cqe);

    close(fd);
    io_uring_queue_exit(&ring);
    return 0;
}
```